import multiprocessing
import random
import time
import getpass
import os
import psutil
from datetime import datetime


class Logger:
    def __init__(self, log_file='app.log'):
        self.log_file = log_file
        self.username = getpass.getuser()
        
    def log(self, level, message):
        timestamp = datetime.now().strftime("%d.%m.%Y %H:%M:%S")
        log_entry = f"[{level}] [{timestamp}] [{self.username}] - {message}\n"
        
        with open(self.log_file, 'a') as f:
            f.write(log_entry)


def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr


def merge_sorted_arrays(arrays):
    result = []
    pointers = [0] * len(arrays)
    
    while True:
        min_val = None
        min_idx = -1
        
        for i in range(len(arrays)):
            if pointers[i] < len(arrays[i]):
                current = arrays[i][pointers[i]]
                if min_val is None or current < min_val:
                    min_val = current
                    min_idx = i
        
        if min_idx == -1:
            break
            
        result.append(min_val)
        pointers[min_idx] += 1
    
    return result


def sort_worker(arr, result_queue, logger):
    try:
        logger.log("INFO", "Начата сортировка части массива")
        sorted_arr = bubble_sort(arr)
        result_queue.put(sorted_arr)
        logger.log("INFO", "Сортировка части массива завершена")
    except Exception as e:
        logger.log("ERROR", f"Ошибка при сортировке: {str(e)}")
        result_queue.put(None)


def save_worker(result_queue, save_queue, logger):
    try:
        while True:
            if not result_queue.empty():
                result = result_queue.get()
                if result is None: 
                    break
                
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"sorted_part_{timestamp}.txt"
                with open(filename, 'w') as f:
                    f.write(','.join(map(str, result)))
                logger.log("INFO", f"Сохранен результат в файл {filename}")
                save_queue.put(filename)
            time.sleep(0.1)
    except Exception as e:
        logger.log("ERROR", f"Ошибка в процессе сохранения: {str(e)}")


def get_available_processes():
    total_cores = os.cpu_count()
    cpu_percent = psutil.cpu_percent(interval=1)
    available_ratio = (100 - cpu_percent) / 100
    available_processes = int(total_cores * available_ratio)

    return max(1, min(available_processes, total_cores))


def main():
    logger = Logger()
    
    try:
        logger.log("INFO", "Программа запущена")

        n = int(input("Введите количество элементов в массиве: "))
        logger.log("INFO", f"Пользователь ввел размер массива: {n}")

        arr = [random.randint(0, 1000) for _ in range(n)]

        available_processes = get_available_processes()
        max_processes = min(available_processes, os.cpu_count())
        
        print(f"Доступно процессов: {max_processes} (из {os.cpu_count()})")
        num_processes = int(input(f"Введите количество процессов для сортировки (1-{max_processes}): "))
        
        if num_processes < 1 or num_processes > max_processes:
            raise ValueError("Недопустимое количество процессов")
            
        logger.log("INFO", f"Пользователь выбрал {num_processes} процессов для сортировки")

        chunk_size = n // num_processes
        chunks = [arr[i*chunk_size:(i+1)*chunk_size] for i in range(num_processes-1)]
        chunks.append(arr[(num_processes-1)*chunk_size:])

        result_queue = multiprocessing.Queue()
        save_queue = multiprocessing.Queue()

        processes = []
        for chunk in chunks:
            p = multiprocessing.Process(target=sort_worker, args=(chunk, result_queue, Logger()))
            processes.append(p)
            p.start()

        saver = multiprocessing.Process(target=save_worker, args=(result_queue, save_queue, Logger()))
        saver.start()

        for p in processes:
            p.join()

        result_queue.put(None)
        saver.join()

        sorted_chunks = []
        while not result_queue.empty():
            chunk = result_queue.get()
            if chunk is not None:
                sorted_chunks.append(chunk)

        final_sorted = merge_sorted_arrays(sorted_chunks)

        with open('final_sorted.txt', 'w') as f:
            f.write(','.join(map(str, final_sorted)))
        
        logger.log("INFO", "Финальный отсортированный массив сохранен в final_sorted.txt")
        print("Сортировка завершена. Результат сохранен в final_sorted.txt")
        
    except ValueError as ve:
        logger.log("ERROR", f"Ошибка ввода: {str(ve)}")
        print(f"Ошибка: {str(ve)}")
    except Exception as e:
        logger.log("ERROR", f"Неожиданная ошибка: {str(e)}")
        print(f"Произошла ошибка: {str(e)}")
    finally:
        logger.log("INFO", "Программа завершена")


if __name__ == "__main__":
    main()
